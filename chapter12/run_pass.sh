#!/bin/bash 

echo -e  "\033[36m 

   run-parts
   run-parts 命令 [1] 将会执行目标目录中所有的脚本,
   这些将本会以 ASCII 的循序进行排列. 当然, 这些脚本都
   需要具有可执行权限.

   cron 幽灵进程 会调用 run-parts 来运行 /etc/cron.* 下的所有脚本.

   yes
   yes 命令的默认行为是向 stdout 中连续不断的输出字符 y,
   每个 y 占一行.使用 control-c来结束运行. 如果想换一个输
   出字符的话, 可以使用 yes 其他的字符串, 这样就会连续
   不同的输出你指定的字符串. 那么这样的命令究竟能做什么呢?
   在命令行或者脚本中,yes 的输出可以通过重定向或管道来传递
   给一些需要用户输入进行交互的命令. 事实上,这个命令可以说是
   expect 命令(译者注: 这个命令本书未介绍, 一个自动实现交互的命
   令)的一个简化版本.

   yes | fsck /dev/hda1 将会以非交互的形式运行 fsck(因为需要
   用户输入的 y 全由 yes命令搞定了)(小心使用!).

   yes | rm -r dirname 与 rm -rf dirname 效果相同(小心使用!).

   注意: 当用 yes 的管道形式来使用一些可能具有潜在危险的系统命令的时候一定要深思
   熟虑, 比如 fsck 或 fdisk. 可能会产生一些意外的副作用.

   banner
   将会把字符串用一个 ASCII 字符(默认是 '#')来画出来
   (就是将多个'#'拼出一副字符的图形).可以作为硬拷贝
   重定向到打印机上(译者注: 可以使用-w 选项设置宽度).


   printenv
   对于某个特定的用户, 显示出所有的 环境变量.
   bash$ printenv | grep HOME
   HOME=/home/bozo

   lp
   lp 和 lpr 命令将会把文件发送到打印队列中, 并且作为硬拷贝来打印. [2] 这些命令
   会纪录它们名字的起始位置并传递到行打印机的另一个位置.<rojy bug>
   bash$ lp file1.txt 或者 bash lp <file1.txt
   通常情况下都是将 pr 的格式化的输出传递到 lp.
   bash$ pr -options file1.txt | lp
   格式化的包, 比如 groff 和 Ghostscript 就可以将它们的输出直接发送给 lp.
   bash$ groff -Tascii file.tr | lp
   bash$ gs -options | lp file.ps还有一些相关的命令, 比如 lpq, 可以查看打印队列, lprm, 可以用来从打印队列中删除作业.

    tee
    [UNIX 从管道行业借来的主意.]
    这是一个重定向操作, 但是有些不同. 就像管道中的"三通"一样, 这个命令可以将命令或
    者管道命令的输出抽出到一个文件中,而且并不影响结果. 当你想将一个正在运行的进程
    的输出保存到文件中时, 或者为了 debug 而保存输出记录的时候, 这个命令就非常有用了.
    (重定向)
    |----> to file
    |
    ==========================|====================
    command ---> command ---> |tee ---> command ---> ---> output of pipe
    ===============================================
    1 cat listfile* | sort | tee check.file | uniq > result.file
    (在对排序的结果进行 uniq (去掉重复行) 之前,文件 check.file 中保存了排过序的
    "listfiles".)


    mkfifo
    这个不大引人注意的命令可以创建一个命名管道, 并产生一个临时的先进先出的 buffer 用来在两个进程间传输数据. [3] 典型的使用是一个进程向 FIFO 中写数据, 另一个进程读出来. 参见 Example A-15.
     
    pathchk
    这个命令用来检查文件名的有效性. 如果文件名超过了最大允许长度(255 个字符), 或者 它所在的一个或多个路径搜索不到, 那么就会产生一个错误结果.  不幸的是,并不能够返回一个可识别的错误码, 因此它在脚本中几乎没有什么用. 一般都 使用文件测试操作.

   dd
   这也是一个不太出名的工具, 但却是一个令人恐惧的 "数据复制" 命令. 最开始, 这个命 令是被用来在 UNIX 微机和 IBM 大型机之间通过磁带来交换数据, 这个命令现在仍然有它的 用途. dd 命令只不过是简单的拷贝一个文件 (或者 stdin/stdout), 但是它会做一些转 换. 下边是一些可能的转换, 比如 ASCII/EBCDIC, [4] 大写/小写, 在输入和输出之间 的字节对的交换, 还有对输入文件做一些截头去尾的工作. dd --help 列出了所有转换, 还有这个强力工具的一些其他选项.
   1 # 将一个文件转换为大写:
   2
   3 dd if=\$filename conv=ucase > \$filename.uppercase4 #
   lcase
   # 转换为小写

\033[0m"
