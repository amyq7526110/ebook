#!/bin/bash 

   #  mktemp 
 
   #   使用一个"唯一"的文件名来创建一个 临时文件 [4] . 
   #   如果不带参数的在命令行下调用这个命令时, 将会在 /tmp 
   #   目录下产生一个零长度的文件.

   mktemp

   # /tmp/tmp.zzsvql3154

   PREFIX=`mktemp $PREFIX.XXXXXX`


   #                      ^^^^^^ 在这个临时的文件名中
   #+                            至少需要 6 个占位符


   #   如果没有指定临时文件的文件名,
   #+  那么默认就是 "tmp.XXXXXXXXXX".

   echo "tempfile name = $tempfile"

   # tempfile name = filename.QA2Zpy

   #         或者一些其他的相似的名字...

   # 使用 600 为文件权限
   #+ 来在当前工作目录下创建一个这样的文件.
   # 这样就不需要 "umask 177" 了.
   # 但不管怎么说, 这也是一个好的编程风格.

   #  make
   #  build 和 compile 二进制包的工具. 当源文件被增加或修改时就会
   #  触发一些操作, 这个工具用来控制这些操作.
   #  make 命令将会检查 Makefile, makefile 是文件的依赖和操作列表.

   #  install
   #  特殊目的的文件拷贝命令, 与 cp 命令相似, 但是具有设置拷贝文件
   #  的权限和属性的能力.这个命令看起来是为了安装软件包所定制的, 
   #  而且就其本身而言, 这个命令经常出现在Makefile 中(在 make install : 区中). 
   #  在安装脚本中也会看到这个命令的使用.

   #  dos2unix
   #  这个工具是由 Benjamin Lin 和其同事编写的, 目的是将 DOS 格式的文本文件
   #  (以 CR-LF 为行结束符) 转换为 UNIX 格式 (以 LF 为行结束符), 反过来也一样.



   # ptx
   # ptx [targetfile] 命令将会输出目标文件的序列改变的索引(交叉引用列表). 如果必要的
   # 话, 这个命令可以在管道中进行更深层次的过滤和格式化.
   # more, less
   # 分页显示文本文件或 stdout, 一次一屏.可以用来过滤 stdout 的输出 . . . 或一个脚本
   # 的输出.
   # more 命令的一个有趣的应用就是测试一个命令序列的执行, 来避免可能发生的糟糕的
   # 结果.
   # ls /home/bozo | awk '{print "rm -rf " $1}' | more
   # #
   # 
   # # 检测下边(灾难性的)命令行的效果:
   # #
   # #                                             ^^^^
   # ls /home/bozo | awk '{print "rm -rf " $1}' | sh
   # 推入 shell 中执行 . . .
 
   
   #  注意事项:
   #  [1]
   #  在这里所讨论的一个归档文件, 只不过是存储在一个单一位置上的一些相关文件的
   #  集合.
   #  [2]
   #  tar czvf archive_name.tar.gz * 可以 包含当前工作目录下的点文件. 这是一个
   #  未文档化的 GNU tar 的"特征".
   #  [3]
   #  这是一个对称的块密码, 过去曾在单系统或本地网络中用来加密文件, 用来对抗
   #  "public key" 密码类, pgp 就是一个众所周知的例子.
   #  [4]
   #  使用 -d 选项可以创建一个临时的目录.

   
