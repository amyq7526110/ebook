#!/bin/bash 

#  ln  
#   
#   创建文件链接, 前提是这个文件是存在的.
#
#   "链接" 就是一个文件的引用, 也就是这个文件的另一个名字. 
#
#   ln 命令允许对同一个文件引用多个链接,并且是避免混淆的一个很好的方法 
#
#   ln 对于文件来说只不过是创建了一个引用,
#      一个指针而已, 因为创建出来的连接文件只有几个字节.
#
#   绝大多数使用 ln 命令时使用是 -s 选项, 可以称为符号链接, 或软链接.使用 -s 选项的 一个优点是它可以穿越文件系统来链接目录.
#
#   关于使用这个命令的语法还是有点小技巧的. 
#
#   比如: ln -s oldfile newfile 将对老文件 产生一个新的文件链接.
#
#   注意: 如果之前就存在 newfile 的话, 那么将会产生一个错误消息.
#
#   使用链接中的哪种类型?
#
#   就像 John Macdonald 解释的那样:
#
#   不论是那种类型的链接, 都提供了一种双向引用的手段 -- 也就是说, 不管你用文件
#   的那个名字对文件内容进行修改, 你修改的效果都即会反映到原始名字的文件, 也会
#   反映到链接名字的文件.当你工作在更高层次的时候, 才会发生软硬链接的不同. 硬链
#   接的优点是, 原始文件与链接文件之间是相互独立的 -- 如果你删除或者重命名老文
#   件, 那么这种操作将不会影响硬链接的文件, 硬链接的文件讲还是原来文件的内容.
#   然而如果你使用软链接的, 当你把老文件删除或重命名后, 软链接将再也找不到原来
#   文件的内容了. 而软链接的优点是它可以跨越文件系统(因为它只不过是文件名的一个
#   引用, 而并不是真正的数据). 与硬链接的另一个不同是, 一个符号链接可以指向一个
#   目录.
#   链接给出了一种可以用多个名字来调用脚本的能力(当然这也适用于任何可执行的类型),
#   并且脚本的行为将依赖于脚本是如何被调用的.



    # hello.sh 显示"hello" 还是 "goodbye"

    #+       依赖于 脚本是如何被调用的

    # 在当前目录上($PWD)为这个脚本创建一个链接

    #  ln -s hello.sh goodbye

    #  现在。通过如下两种方法来调用这个脚本
    # ./hello.sh

    # ./goodbye

    Hello_Call=65

    GoodBye_Call=66

    if [ $0 = "./goodbye" ]

    then

       echo "Good-bye!"

       # 当然，在这里你也可以添加一些其他的goodbye 类型的命令，
       # Some other goodbye-type commands as apprapriate

       exit $GoodBye_Call 

    fi

    echo "Hello !"

    #  当然, 在这里你也可以添加一些其他的 hello 类型的命令

    exit $Hello_Call 

















      
