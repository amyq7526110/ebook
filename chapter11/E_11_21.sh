#!/bin/bash


#   如果引入的文件本身就是一个可执行脚本的话,那么它将运行起来,当它 return 的时候,控制 权又重新回到了引用它的脚本中.一个用 source 引入的脚本可以使用 return 命令来达到这 个目的.

#   也可以向需要 source 的脚本中传递参数.这些参数在 source 脚本中被认为是位置参数.  1 source $filename $arg1 arg2

#   你甚至可以在脚本文件中 source 脚本文件自身,虽然看不出有什么实际的应用价值.


    #  self-source.sh  一个脚本递归传递本身

    MaxPassCnt=100  # source 自身的最大的数量

    echo -n "$pass_count "

    #  第一次运行的时候，这句话只不过 echo 两个空格

    #+ 因为$pass_count 还没有初始化

    let "pass_count += 1"

    #  假定这个为初始化变量 $pass_count 

    #+ 可以在第一次运行的时候加一

    # 这句话可以正常工作在 bash 和 pdksh 但是

    #+它依赖于不可移植性(并且可能危险的行为)

    # 更好的方法是在使用$pass_count 之前,先把这个变量初始化为 0.

    while [ "$pass_count" -le "$MaxPassCnt" ]

    do 
       . $0  # 脚本"sources" 自身, 而不是调用自己.
       
       # ./$0 (应该能够正常递归) 但是不能在这正常运行. 为什么?

    done  

    # 这里发生的动作并不是真正的递归,
    #+ 因为脚本成功的展开了自己,换句话说,
    #+ 在每次循环的过程中
    #+ 在每个'source'行(第 20 行)上
    # 都产生了新的代码.
    #
    # 当然,脚本会把每个新'sourced'进来的文件的"#!"行
    #+ 都解释成注释,而不会把它看成是一个新的脚本.

    echo

    exit 0   # 最终的效果就是从 1 数到 100.

    # 让人印象深刻.
    # 练习:
    # -----
    # 使用这个小技巧编写一些真正能干些事情的脚本.a


